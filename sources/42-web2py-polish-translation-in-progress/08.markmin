## Wiadomości Email i SMS

``wiadomości email``:inxx

### Konfiguracja obsługi poczty elektronicznej

Platforma web2py udostępnia klasę ``gluon.tools.Mail`` umożliwiającą łatwe wysyłanie wiadomości email z poziomu web2py. Definicja mailera może wyglądać następująco:
``
from gluon.tools import Mail
mail = Mail()
mail.settings.server = 'smtp.przyklad.com:25'
mail.settings.sender = 'twoj@przyklad.com'
mail.settings.login = 'użytkownik:hasło'
``:code

Uwaga, jeśli aplikacja stosuje uwierzytelnianie ``Auth`` (omówione w następnej części), to obiekt ``auth`` będzie udostępniał własny mailer w metodzie ``auth.settings.mailer``, tak więc można zamiennie zastosować następujące ustawienia:
``
mail = auth.settings.mailer
mail.settings.server = 'smtp.przyklad.com:25'
mail.settings.sender = 'twoj@przyklad.com'
mail.settings.login = 'użytkownik:hasło'
``:code

W mail.settings wstaw odpowiednie parametry swojego serwera SMTP. Ustaw ``mail.settings.login = None`` jeśli serwer SMTP nie wymaga uwierzytelnienia. Jeśli nie zamierzasz używać TLS, ustaw ``mail.settings.tls = False``

``rejestracja zdarzeń poczty elektronicznej``:inxx

--------
W celu śledzenia błędów ustaw:
``
mail.settings.server = 'logging'
``:code
a wiadomości email nie będą wysyłane, lecz zapisywane do konsoli.
-------

#### Konfiguracja poczty elektronicznej w Google App Engine
``poczta elektroniczna w GAE``:inxx
Aby wysłać wiadomość email z konta na Google App Engine:

``
mail.settings.server = 'gae'
``:code

W czasie pisania tego tekstu web2py nie obsługiwał załączników i szyfrowania wiadomości na Google App Engine. Trzeba mieć na uwadze, że cron i terminarz nie działają w GAE.

#### Szyfrowanie x509 i PGP
``PGP``:inxx ``x509``:inxx

W celu wysyłania wiadomości email zaszyfrowanych w standardzie x509 (SMIME) trzeba wykonać następującą konfigurację:
``
mail.settings.cipher_type = 'x509'
mail.settings.sign = True
mail.settings.sign_passphrase = 'twoja tajna fraza'
mail.settings.encrypt = True
mail.settings.x509_sign_keyfile = 'nazwapliku.key'
mail.settings.x509_sign_certfile = 'nazwapliku.cert'
mail.settings.x509_crypt_certfiles = 'nazwapliku.cert'
``:code

Istnieje możliwość wysyłania wiadomości email szyfrowanych w PGP. Przede wszystkim należy zainstalować pakiet python-pyme. Następnie można użyć GnuPG (GPG) w celu utworzenia pliku klucza dla metody sender (pobierającej adres wiadomości z mail.settings.sender) oraz umieścić pliki pubring.gpg i secring.gpg w katalogu (np. "/home/www-data/.gnupg").

Zastosuj nastepujące ustawienia:

``
mail.settings.gpg_home = '/home/www-data/.gnupg/'
mail.settings.cipher_type = 'gpg'
mail.settings.sign = True
mail.settings.sign_passphrase = 'twoja tajna fraza'
mail.settings.encrypt = True
``:code

### Wysyłanie wiadomości email
``mail.send``:inxx ``email html``:inxx ``email attachments``:inxx

Po zdefiniowaniu mailera ``mail`` wiadomość email można wysłać stosując:
``
mail.send(to=['somebody@example.com'],
          subject='hello',
          # Jeśli reply_to zostanie pominięty, użyty zostanie mail.settings.sender 
          reply_to='us@example.com',
          message='Hi there')
``:code

Metoda ``mail.send()`` w razie powodzenia zwraca True a w przeciwnym wypadku False. Pełny wykaz argumentów tej metody jest następujący:
``
send(self, to, subject='None', message='None', attachments=[],
     cc=[], bcc=[], reply_to=[], sender=None, encoding='utf-8',
     raw=True, headers={})
``:code

Proszę zwrócić uwagę, że każdy z argumentów ``to``, ``cc``, and ``bcc`` pobiera listę adresów emailowych.

``sender`` ustawiony jest domyślnie na ``None`` i w tym przypadku nadawca będzie ustawiony na  ``mail.settings.sender``.

``headers`` jest słownikiem nagłówków do oczyszczenia przed wysłaniem wiadomości email. Na przykład:

``
headers = {'Return-Path' : 'bounces@example.org'}
``:code

Poniżej zademonstrowane są dodatkowe przykłady użycia ``mail.send()``.

#### Prosty tekst wiadomości email

``
mail.send('you@example.com',
  'Message subject',
  'Plain text body of the message')
``:code

#### Wiadomości email w formacie HTML 

``
mail.send('you@example.com',
  'Message subject',
  '<html>html body</html>')
``:code

Jeśli zawartość wiadomości email zaczyna się od ``<html>`` i kończy na ``</html>``, zostanie ona wysłana jako wiadomość email HTML.

#### Połączenie emaila tekstowego z emailem HTML

Wiadomość zawarta w emailu może mieć postać krotki (text, html):

``
mail.send('twój@przykład.com',
  'Message subject',
  ('Plain text body of the message', '<html>html body</html>'))
``:code

#### Adresy email ``cc`` i ``bcc`` 

``
mail.send('you@example.com',
  'Message subject',
  'Plain text body of the message',
  cc=['other1@example.com', 'other2@example.com'],
  bcc=['other3@example.com', 'other4@example.com'])
``:code

#### Załączniki

``
mail.send('you@example.com',
  'Message subject',
  '<html><img src="cid:zdjęcie" /></html>',
  zalaczniki = mail.Attachment('/scieżka/do/zdjęcia.jpg', content_id='zdjęcie'))
``:code

#### Wiele załączników

``
mail.send('you@example.com',
  'Message subject',
  'Plain text body of the message',
  zalaczniki = [mail.Attachment('/ścieżka/do/pierwszego.pliku'),
                 mail.Attachment('/ścieżka/do/drugiego.pliku')])
``:code

### Wysyłanie wiadomości SMS
``SMS``:inxx
Wysyłanie wiadomości SMS za pomocą aplikacji web2py wymaga usługi firmy trzeciej, która może przesłać wiadomości do odbiorcy. Zazwyczaj jest to usługa odpłatna, ale zależy to od kraju. Sprawdziliśmy kilka z nich, niestety ze słabym skutkiem. Firmy telekomunikacyjne blokują emaile wysyłane za ich pomocą, gdyż są one najczęściej źródłem spamu. 

Lepszym rozwiązaniem jest wykorzystanie firm telekomunikacyjnych. Bowiem każda z nich przypisuje unikatowy adres emailowy do numeru telefonu komórkowego, dzięki czemu wiadmości SMS mogą być wysyłane jako wiadomości email na telefon komórkowy. 

Web2py posiada moduł, który ułatwia to zadanie:
``
from gluon.contrib.sms_utils import SMSCODES, sms_email
email = sms_email('1 (111) 111-1111','T-Mobile USA (tmail)')
mail.send(to=email, subject='test', message='test')
``:code

SMSCODES to słownik odwzorowujący nazwy głównych firm telekomunikacyjnych na adresy email postfixa. Funkcja sms_email pobiera numer telefonu (jako ciąg znakowy) i nazwę firmy telekomunikacyjnej, a zwraca adres email telefonu.

### Wykorzystanie systemu szablonów do generowania wiadomości
``wiadomości email``:inxx

Do wygenerowania wiadomości można wykorzystać system szablonów. Na przykład, rozważmy przykładową tabelę bazy danych:
``
db.define_table('person', Field('name'))
``:code

gdzie do każdej osoby w bazie danych chcemy wysłać następującą wiadomość, zapisaną w pliku  widoku "message.html":
``
Drogi {{=person.name}},
Wygrałeś drugą nagrodę, zestaw noży do krojenia steków.
``:code

Można tego dokonać w następujący sposób:
``
for person in db(db.person).select():
    context = dict(person=person)
    message = response.render('message.html', context)
    mail.send(to=['who@example.com'],
              subject='None',
              message=message)
``:code

Większą część zadania wykonuje wyrażenie
``
response.render('message.html', context)
``:code

Kod ten renderuje widok "message.html" ze zmiennymi zdefiniowanymi w słowniku "context" i zwraca ciąg znakowy z przetworzonym tekstem wiadomości email. Argument context jest słownikiem zawierającym zmienne, które będą widoczne w pliku szablonowym.

Jeśli zawartość wiadomości email zaczyna się od ``<html>`` i kończy na ``</html>``, to wiadomość email będzie miała format HTML.

Uwaga, jeśli chce się umieścić w zawartości HTML odnośnik zwrotny do swojej strony, to można skorzystać z funkcji ``URL``. Aczkolwiek, funkcja ``URL`` domyślnie generuje względny adres URL, który może nie działać w poczcie elektronicznej. Aby wygenerować bezwzględny adres URL, należy określić w funkcji URL argumenty ``scheme`` i ``host``. Na przykład:

``
<a href="{{=URL(..., scheme=True, host=True)}}">Kliknij tutaj</a>
``:code

lub

``
<a href="{{=URL(..., scheme='http', host='www.strona.com')}}">Kliknij tutaj</a>
``:code

Ten sam mechanizm, który służy do wygenerowania tekstu wiadomości email może być również wykorzystany do wygenerowania wiadomości SMS jak i wiadomości innego typu.

### Wysyłanie wiadomości za pomocą zadania uruchomionego w tle


Operacja wysyłania wiadomości email może potrwać kilka sekund, ponieważ konieczne jest zalogowanie się i nawiązanie łączności ze zdalnym serwerem SMTP, z którego przeważnie się korzysta. Aby skrócić czas oczekiwania przez użytkownika na zakończenie tej operacji, pożądane jest czasem ustawienie wiadomości email w kolejce, tak aby wysłana była później poprzez zadanie działające w tle. Jak opisano w Rozdziale 4, zadanie takie można ustawić samemu tworząc własną kolejkę lub korzystając z terminarza. Poniżej przedstawiamy przykład wykorzystania własnej kolejki zadań.


Najpierw, w pliku modelu aplikacji tworzymy model bazy danych do przechowywania kolejki email:
``
db.define_table('queue',
    Field('status'),
    Field('email'),
    Field('subject'),
    Field('message'))
``:code

Następnie w kontrolerze ustawiamy w kolejce wiadomości do wysłania:
``
db.queue.insert(status='pending',
                email='you@example.com',
                subject='test',
                message='test')
``:code

Po czym utworzymy skrypt działający w tle, który odczyta kolejkę i wyśle wiadomości:
``
## w pliku /app/private/mail_queue.py
import time
while True:
    rows = db(db.queue.status=='pending').select()
    for row in rows:
        if mail.send(to=row.email,
            subject=row.subject,
            message=row.message):
            row.update_record(status='sent')
        else:
            row.update_record(status='failed')
        db.commit()
    time.sleep(60) # sprawdzaj co minutę
``:code

Na sam koniec, tak jak opisano w Rozdziale 4, musimy wykonać skrypt mail_queue.py w taki sposób, jak by był umieszczony wewnątrz kontrolera aplikacji.
``
python web2py.py -S app -M -R applications/app/private/mail_queue.py
``:code

gdzie opcja ``-S app`` nakazuje web2py wykonanie "mail_queue.py" jako "app", ``-M`` nakazuje web2py wykonanie operacji na modelach.

Zakładamy, że obiekt ``mail`` przywoływany w skrypcie "mail_queue.py" został zdefiniowany w pliku modelu aplikacji i dlatego, że użyto opcję ``-M``, jest dostępny w skrypcie "mail_queue.py". W celu uniknięcia zablokowania bazy danych przez inny, współbieżny proces, ważne jest, aby wprowadzać jak najszybciej każdą zmianę.

Jak wspomniano w Rozdziale 4, ten typ procesów uruchamianych w tle nie powinien być wykonywany przez  cron (za wyjątkiem, powiedzmy, cron @reboot), gdyż tylko jedno zdarzenie takiego typu może być wykonywane w danej chwili.

Jedną z wad wysyłania wiadomości email z wykorzystaniem procesu działającego w tle jest to, że trudno jest dostarczyć użytkownikowi informację zwrotną w przypadku niepowodzenia wysyłki. Jeśli wiadomość email zostanie wysłana bezpośrednio z poziomu akcji kontrolera, to można przechwycić błędy i natychmiast zwrócić komunikat o błędzie. Jednakże w przypadku procesu działającego tle, wiadomość email jest wysyłana asynchronicznie już po zwróceniu odpowiedzi przez akcję kontrolera, utrudniając tym samym powiadomienie użytkownika o błędzie.


### Czytanie i zarządzanie skrzynkami pocztowymi (Eksperymentalne)

Adapter ``IMAP`` jest interfejsem serwerów IMAP wykonujących proste kwerendy składni ``DAL`` web2py, tak więc wiadomości są odczytywane, wyszukiwane oraz wykonywane są inne usługi związane z pocztą IMAP, na przykład usługi zaimplementowane przez przez marki Google(r) i Yahoo(r) mogą być zarządzanie z poziomu aplikacji web2py.

Adapter ten tworzy "statycznie" własne tabele nazwy pól, co oznacza, że programista nie powinien ich sam definiować, pozostawiając to zadanie instancji DAL przez wywołanie metody adaptera`` .define_tables()``. Tabele zostają zdefiniowane z informacjami o liście skrzynek pocztowych serwera IMAP. 


#### Nawiązanie połączenia

Oto zalecany kod rozpoczynający obsługę IMAP w modelu aplikacji dla pojedynczego konta pocztowego.

``
# Zamień odpowiednio user, password, server i port w łańcuchu połączenia
# Ustaw port na 993 przy obsłudze SSL
imapdb = DAL("imap://user:password@server:port", pool_size=1)
imapdb.define_tables()
``:code

Proszę zwrócić uwagę, że ``<imapdb>.define_tables()`` zwraca słownik łańcuchów odwzorowujących nazwy tabel DAL na nazwy skrzynek pocztowych serwera o następującej strukturze ``{<tablename>: <server mailbox name>, ...}``, tak więc istnieje możliwość pobrania rzeczywistej nazwy skrzynki pocztowej na serwerze IMAP.

W celu stworzenia własnej konfiguracji tabela/skrzynka pocztowa i pominięcia automatycznej konfiguracji nazw, można przekazać do adaptera własny słownik w ten sposób:

``
imapdb.define_tables({"inbox": "MAILBOX", "trash", "SPAM"})
``:code

Aby umożliwić obsługę różnych natywnych nazw skrzynek pocztowych w interfejsie użytkownika, web2py udostępnia następujące atrybuty pozwalające na dostęp automatycznie odwzorowywanych nazw (gdzie natywnej nazwie skrzynki pocztowej odpowiada nazwa tabeli i odwrotnie):

-------------------------------------
**Attribute** | **Type** | **Format**
imapdb.mailboxes | dict | ``{<tablename>: <server native name>, ...}``
imapdb.<table>.mailbox | string | ``"server native name"``
-------------------------------------

Pierwszy z tych atrybutów może być przydatny do pobierania zestawu zapytań IMAP przez natywną skrzynkę pocztową usługi poczty elektronicznej

``
# mailbox jest ciągiem znakowym zawierającym rzeczywistą nazwę skrzynki pocztowej
tablenames = dict([(v,k) for k,v in imapdb.mailboxes.items()])
myset = imapdb(imapdb[tablenames[mailbox]])
``:code

#### Pobieranie poczty i aktualizowanie flag

Oto lista poleceń IMAP, które można zastosować w kontrolerze. Na potrzeby poniższych przykładów, zakłada się, że usługa IMAP ma skrzynkę pocztową o nazwie ``INBOX``, tak samo jak w przypadku kont Gmail(r).

Dla zliczenia dzisiejszych nieprzeczytanych wiadomości mniejszych niż 60000 oktetów w skrzynce pocztowej Inbox, wykonaj:
``
q = imapdb.INBOX.seen == False
q &= imapdb.INBOX.created == request.now.date()
q &= imapdb.INBOX.size < 6000
unread = imapdb(q).count()
``:code


Wiadomości z poprzedniego zapytania mozna zebrać stosując:
``
rows = imapdb(q).select()
``:code


Zaimplementowane zostały popularne operatory zapytań, w tym belongs:

``
messages = imapdb(imapdb.INBOX.uid.belongs(<uid sequence>)).select()
``:code

**Uwaga**: W celu uniknięcie zatorów serwera pocztowego w wyniku dużych poleceń wybierających (select), zaleca się, aby utrzymywać wyniki zapytań poniżej określonego poziomu wielkości danych.

W celu przyśpieszenia zapytań, zaleca się przekazywanie przefiltrowanych zestawów pól:
``
fields = ["INBOX.uid", "INBOX.sender", "INBOX.subject", "INBOX.created"]
rows = imapdb(q).select(*fields)
``:code

Adapter wie kiedy ma pobrać cząstkowe porcje wiadomości ( pola takie jak ``content``,``size`` i ``attachments`` wymagają pobrania całości danych z tych pól).

Wyniki zapytania wybierającego (select) można przefiltrować wykorzystując pola limitby oraz sequences skrzynki pocztowej.
``
#Zamień te wartości argumentów na rzeczywiste wartości
myset.select(<fields sequence>, limitby=(<int>, <int>))
``:code

Powiedzmy, że chcemy napisać akcje aplikacji wyświetlającą wiadomość ze skrzynki pocztowej. Najpierw pobieramy tą wiadomość (jeśli usługa IMAP daje taką możliwość, trzeba pobrać wiadomości używając pole ``uid``, aby uniknąć odniesień do starej sekwencji).

``
mymessage = imapdb(imapdb.INBOX.uid == <uid>).select().first()
``:code

W przeciwnym razie można użyć ``id`` wiadomości.

``
mymessage = imapdb.INBOX[<id>]
``:code

Trzeba pamiętać, że używanie identyfikatora (id) wiadomości jako odniesienia nie jest zalecane, gdyż numeracja sekwencji może się zmienić w wyniku operacji konserwacji skrzynki pocztowej, takich jak usuwanie wiadomości. Jeśli jednak wciąż chcesz zarejestrować odniesienie do wiadomości (czyli w polu rekordu innej bazy danych), rozwiązaniem będzie użycie jako odniesienia pola ``uid``, jeśli jest obsługiwane i pobieranie każdej wiadomości z zarejestrowaną wartością.

Na koniec, aby wyświetlić zawartość wiadomości, dodajmy w widoku coś podobnego do tego kodu:

``
{{=P(T("Message from"), " ", mymessage.sender)}}
{{=P(T("Received on"), " ", mymessage.created)}}
{{=H5(mymessage.subject)}}
{{for text in mymessage.content:}}
  {{=DIV(text)}}
  {{=TR()}}
{{pass}}
``:code


Zgodnie z oczekiwaniami, możemy w widoku skorzystać z helpera ``SQLTABLE`` do zbudowania listy wiadomości:

``
{{=SQLTABLE(myset.select(), linkto=URL(...))}}
``:code

Oczywiście, możliwym jest również zasilenie helpera formularza odpowiednią wartością id sekwencji

``
{{=SQLFORM(imapdb.INBOX, <message id>, fields=[...])}}
``:code

Aktualnie obsługiwane adaptery udostępniają następujące pola:

---------------------------------------
**Pole** | **Typ** | **Opis**
uid | string | ````
answered | boolean | Flaga
created | date | ````
content | list:string | Lista zawierająca elementy tekstowe lub fragmenty html
to | string | ````
cc | string | ````
bcc | string | ````
size | integer | Ilość oktetów wiadomości email*
deleted | boolean | Flaga
draft | boolean | Flaga
flagged | boolean | Flaga
sender | string | ````
recent | boolean | Flaga
seen | boolean  | Flaga
subject | string| ````
mime | string | Deklaracja nagłówka mime
email | string | Kompletny komunikat RFC822**
attachments | list | Każda nietekstowa zakodowana część jako słownik
encoding | string | Wykryty główny zestaw znakowy wiadomości
---------------------------------------------------

*Na stronie aplikacji jest to mierzone jako długość łańcucha komunikatu RFC822 

**UWAGA**: ponieważ identyfikatory wierszy są odwzorowywane na numery sekwencji wiadomości email, trzeba się upewnić, że klient IMAP aplikacji web2py nie usuwa wiadomości w trakcie wykonywania akcji wybierających i aktualizujących.


Nie są obsługiwane standardowe operacje ``CRUD`` bazy danych. Nie ma możliwości zdefiniowania własnych pól lub tabel i wstawiania odmiennych typów danych, gdyż aktualizacja skrzynek pocztowych usług IMAP jest zazwyczaj zredukowana do publikowania na serwerze flagi aktualizacji. Mimo to, możliwe jest uzyskanie dostępu do poleceń poprzez interfejs IMAP mechanizmu DAL.

Aby oznaczyć wiadomości z ostatniego zapytania jako przeczytane:
``
seen = imapdb(q).update(seen=True)
``:code


A tak usuwamy wiadomości w bazie danych IMAP od pana Gumby
``
deleted = 0
for tablename in imapdb.tables():
    deleted += imapdb(imapdb[tablename].sender.contains("gumby")).delete()
``:code


Możliwe jest również oznaczenie wiadomości do usunięcia zamiast wymazywania ich odrazu za pomocą
``
myset.update(deleted=True)
``:code

``IMAP``:inxx
