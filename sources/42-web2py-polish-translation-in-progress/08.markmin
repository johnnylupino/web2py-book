## Email i SMS

``Mail``:inxx

### Konfiguracja maila

Wysyłanie maila w web2py możliwie jest dzięki klasie ``gluon.tools.Mail``. Definicja mailera może wyglądać nastepująco:
``
from gluon.tools import Mail
mail = Mail()
mail.settings.server = 'smtp.przyklad.com:25'
mail.settings.sender = 'twoj@przyklad.com'
mail.settings.login = 'użytkownik:hasło'
``:code

Jeśli twoja aplikacja korzysta z ``Auth`` (omówiony w nastepnym rozdziale), obiekt ``auth`` będzie posiadał własny mailer ``auth.settings.mailer``, który możesz użyć w poniższy sposób:
``
mail = auth.settings.mailer
mail.settings.server = 'smtp.przyklad.com:25'
mail.settings.sender = 'twoj@przyklad.com'
mail.settings.login = 'użytkownik:hasło'
``:code

W mail.settings wstaw odpowiednie parametry swojego serwera SMTP. Ustaw ``mail.settings.login = None`` jeśli serwer SMTP nie wymaga uwierzytelnienia. Jeśli nie zamierzasz używać TLS, ustaw ``mail.settings.tls = False``

``email logging``:inxx

--------
W celu śledzenia błędów ustaw:
``
mail.settings.server = 'logging'
``:code
a maile nie będą wysyłane, lecz zapisywane do konsoli.
-------

#### Konfiguracja emaila w Google App Engine
``email from GAE``:inxx
Aby wysłać email z konta Google App Engine:

``
mail.settings.server = 'gae'
``:code

W czasie kiedy pisano ten tekst, web2py nie obsługiwał załączników i zaszyfrowanych emaili w Google App Engine. Miej na uwadze fakt, że cron i scheduler nie działają w GAE.

#### Szyfrowanie x509 i PGP
``PGP``:inxx ``x509``:inxx

Maile zaszyfrowane systemem x509 (SMIME) można wysłać korzystając z poniższych ustawień:
``
mail.settings.cipher_type = 'x509'
mail.settings.sign = True
mail.settings.sign_passphrase = 'twoje hasło'
mail.settings.encrypt = True
mail.settings.x509_sign_keyfile = 'nazwapliku.key'
mail.settings.x509_sign_certfile = 'nazwapliku.cert'
mail.settings.x509_crypt_certfiles = 'nazwapliku.cert'
``:code

Możliwe jest również wysyłanie emailii zaszyfrowanych w PGP. W tym celu konieczne jest zainstalowanie pakietu python-pyme. Następnie, używając GnuPG (GPG), utwórz pliki-klucze dla nadawcy (użyj adresu emailowego z mail.settings.sender) i przenieś je do wybranego katalogu (np. "/home/www-data/.gnupg").

Zastosuj nastepujące ustawienia:

``
mail.settings.gpg_home = '/home/www-data/.gnupg/'
mail.settings.cipher_type = 'gpg'
mail.settings.sign = True
mail.settings.sign_passphrase = 'twoje hasło'
mail.settings.encrypt = True
``:code

### Wysyłanie emaila
``mail.send``:inxx ``email html``:inxx ``email attachments``:inxx

Kiedy już zdefiniujesz ``mail`` , można go zacząć używać do wysyłania emailii stosując:
``
mail.send(to=['ktoś@przykład.com'],
          subject='cześć',
          # Jeśli reply_to zostanie pominięty, uzyty zostanie mail.settings.sender 
          reply_to='my@przykład.com',
          message='Jak się masz')
``:code

Mail zwróci ``True`` jeśli operacja wysłania się powiedzie, w przeciwnym przypadku zwróci ``False`` . Pełna lista argumentów dla ``mail.send()`` prezentuje się nastepująco:

``
send(self, to, subject='None', message='None', attachments=[],
     cc=[], bcc=[], reply_to=[], sender=None, encoding='utf-8',
     raw=True, headers={})
``:code

Zwróć uwagę, że ``to``, ``cc``, and ``bcc`` zawierają listę adresów emailowych.

``sender`` ustawiony jest domyślnie na ``None`` i w tym przypadku nadawca będzie ustawiony na  ``mail.settings.sender``.

``headers`` to słownik z nagłówkami, który oczyszcza nagłówki zanim nastapi wysłanie emaila. Na przykład:

``
headers = {'Return-Path' : 'powrót@przykład.org'}
``:code

Poniżej zademonstrowane są dodatkowe przykłady użycia ``mail.send()``.

#### Prosty tekst emailowy

``
mail.send('twój@przykład.com',
  'Tytuł wiadomości',
  'Ciało tekstu wiadomości')
``:code

#### Emaile HTML 

``
mail.send('twój@przykład.com',
  'Tytuł wiadomości',
  '<html>Ciało html</html>')
``:code

Jeśli ciało emaila zaczyna się od ``<html>`` i kończy na ``</html>``, email zostanie wysłany jako HTML.

#### Połączenie emaila tekstowego z emailem HTML

Wiadomość zawarta w emailu może mieć postać tupli (text, html):

``
mail.send('twój@przykład.com',
  'Tytuł wiadomości',
  ('Czysty tekst ciała', '<html>Ciało html</html>'))
``:code

#### Emaile ``cc`` i ``bcc`` 

``
mail.send('twój@przykład.com',
  'Tytuł wiadomości',
  'Czysty tekst ciała',
  cc=['inny1@przykład.com', 'inny2@przykład.com'],
  bcc=['inny3@przykład.com', 'inny4@przykład.com'])
``:code

#### Załączniki

``
mail.send('twój@przykład.com',
  'Tytuł wiadomości',
  '<html><img src="cid:zdjęcie" /></html>',
  zalaczniki = mail.Attachment('/scieżka/do/zdjęcia.jpg', content_id='zdjęcie'))
``:code

#### Wiele załączników

``
mail.send('twój@przykład.com',
  'Tytuł wiadomości',
  'Ciało wiadomości',
  zalaczniki = [mail.Attachment('/ścieżka/do/pierwszego.pliku'),
                 mail.Attachment('/ścieżka/do/drugiego.pliku')])
``:code

### Wysyłanie wiadomości SMS
``SMS``:inxx
Do wysłania wiadomości SMS za pomocą aplikacji web2py konieczna jest usługa zewnętrzna, która prześle wiadomość do odbiorcy. Zazwyczaj jest to usługa odpłatna, ale zależy to od kraju. Sprawdzilismy kilka z nich, niestety ze słabym skutkiem. Firmy telekomunikacyjne blokują emaile wysyłane za ich pomocą, gdyż są one najczęściej źródłem spamu. 

Lepszym wyjściem jest wykorzystanie firm telekomunikacyjnych do przekazywania SMS-ów. Każda z nich, bowiem, przypisuje unikatowy adres emailowy do numeru telefonu komórkowego, dzięki czemu wiadmości SMS mogą być wysyłane jako emaile na telefon komórkowy. 

Web2py posiada moduł, który ułatwia to zadanie:
``
from gluon.contrib.sms_utils import SMSCODES, sms_email
email = sms_email('1 (111) 111-1111','T-Mobile USA (tmail)')
mail.send(to=email, subject='test', message='test')
``:code

SMSCODES to słownik, który przypisuje nazwy największych firm telekomunikacyjnych do przyrostka adresu emailowego. Funkcja ``sms_email`` zwraca adres emailowy telefonu składający się z numeru telefonu (jako ciągu znaków) oraz nazwy firmy telekomunikacyjnej .

### Wykorzystanie systemu szablonów do generowania wiadomości
``emails``:inxx

Do wygenerowania wiadomości można wykorzystać system szablonów. Rozważmy przykładową tablicę bazy danych:
``
db.define_table('osoba', Field('imię'))
``:code

gdzie do każdej osoby w bazie danych chcesz wysłać następującą wiadomość, zawartą w pliku  "message.html" umieszczonym w widoku:
``
Drogi {{=osoba.imię}},
Wygrałeś drugą nagrodę, zestaw noży do krojenia steków.
``:code

Można to osiągnąć w następujący sposób:
``
for person in db(db.person).select():
    context = dict(person=person)
    message = response.render('wiadomość.html', context)
    mail.send(to=['ktos@przykład.com'],
              subject='None',
              message=message)
``:code

Większość pracy wykonuje wyrażenie
``
response.render('wiadomość.html', context)
``:code

Przekazuje ono zmienne zdefiniowane w słowniku "contex" do pliku "wiadomość.html", i zwraca ciąg znaków wraz z tekstem emaila. Context to słownik zawierający zmienne, które będą widoczne dla pliku szablonu.

Jeśli wiadomośc email zaczyna się od ``<html>`` i kończy na ``</html>``, email będzie miał charakter HTML.

Zauważ, że w celu załączenia do wiadomości email linku powrotnego do twojej strony internetowej, możesz użyć funkcji ``URL``. Aczkolwiek, funkcja ``URL`` domyślnie generuje względny adres URL, który nie zadziała w przypadku maila. Aby wygenerować absolutną ścieżkę URL, należy sprecyzować argumenty ``scheme`` i ``host`` w funkcji URL. Na przykład:
``
<a href="{{=URL(..., scheme=True, host=True)}}">Kliknij tutaj</a>
``:code

or

``
<a href="{{=URL(..., scheme='http', host='www.strona.com')}}">Kliknij tutaj</a>
``:code

Ten sam mechanizm szablonów, który służy do generowania tekstu emailowego może posłużyć do stworzenia zarówno wiadomości SMS jak i innego typu wiadomości.

### Wysyłanie wiadomości za pomocą zadania uruchomionego w tle


Wysłanie wiadomości email może trwać nawet do kilkunastu sekund, gdyż najczęściej korzysta się ze zdalnego serwera SMTP wymagającego procesu logowania i nawiązania łączności. Aby skrócić użytkownikowi czas oczekiwania na zakończenie tej operacji, pożądane jest czasem ustawienie wiadomości email w kolejce do wykonania w późniejszym czasie za pomocą zadania w tle. Jak opisano w Rozdziale 4, zadanie takie można ustawić samemu tworząc własna kolejkę lub korzystając z terminarza. Poniżej przedstawiamy przykład wykorzystania własnej kolejki zadań.

Najpierw, w pliku modelu naszej aplikacji tworzymy model bazy danych do przechowywania wiadomości email:
``
db.define_table('kolejka',
    Field('status'),
    Field('email'),
    Field('tytuł'),
    Field('wiadomość'))
``:code

Za pomoca kontrolera wiadomości do wysłania wstawiamy do kolejki:
``
db.queue.insert(status='oczekujące',
                email='twój@przykład.com',
                subject='test',
                message='test')
``:code

Nastepnie, potrzebować będziemy działający w tle skrytp, który odczyta kolejkę i prześle wiadomości:
``
## w pliku /app/private/mail_queue.py
import time
while True:
    rows = db(db.queue.status=='oczekujące').select()
    for row in rows:
        if mail.send(to=row.email,
            subject=row.subject,
            message=row.message):
            row.update_record(status='wysłane')
        else:
            row.update_record(status='nieudane')
        db.commit()
    time.sleep(60) # sprawdzaj co minutę
``:code

Na sam koniec, tak jak opisano w Rozdziale 4, musimy wykonać skrypt w taki sposób, jak gdbyby był umieszczony wewnątrz kontrolera naszej aplikacji.
``
python web2py.py -S app -M -R applications/app/private/mail_queue.py
``:code

gdzie opcja ``-S app`` nakazuje web2py wykonanie "mail_queue.py" jako "app", ``-M`` nakazuje web2py wykonanie operacji na modelach.

Zakładamy , że obiekt ``mail``, do którego odnosi się "mail_queue.py" zdefiniowany jest w pliku modelu naszej alikacji, a dzięki opcji ``-M`` dostępny w skrypcie "mail_queue.py". W celu uniknięcia zablokowania bazy danych przez inny, współbieżny proces, wszelkich zmian należy dokonywać jak najszybciej.

Jak wspomniano w Rozdziale 4, ten typ procesów uruchamianych w tle nie powinien być wykonywany przez  cron (za wyjątkiem, powiedzmy, cron @reboot), gdyż tylko jedno zdarzenie takiego typu może być wykonywane w danej chwili.

Jednym z uniedogodnień korzystania z procesu uruchamianego w tle w celu wysyłania maila jest  trudność przekazania informacji zwrotnej do użytkownika na wypadek, gdyby wysyłka maila zakończyła się niepowodzeniem. Jeśli email zostanie wysłany bezpośrednio z kontrolera, ewentualne błędy mogą być natychmiast przechwycone i przesłane do użytkownika. W przypadku procesu w tle, email wysyłany jest asynchronicznie, już po zwróceniu odpowiedzi przez kontroler, utrudniając tym samym powiadomienie użytkownika o błędzie.


### Czytanie i zarządzanie skrzynkami pocztowymi (Eksperymentalne)

Adapter ``IMAP`` jest interfejsem emailowych serwerów, a jego zadanie polega na wykonywaniu prostych zapytań w składni ``DAL`` web2py, w taki sposób, aby czytanie, przeszukiwanie oraz inne usługi mailowe IMAP takie, jak wdrożone przez Google(r) i Yahoo(r), mogły być zarządzane z poziomu aplikacji web2py.

Tworzy on własne tabele i nazwy pól w sposób "statyczny", a to oznacza, że twórca oprogramowania nie powinien ich sam definiować, lecz pozwolić procesowi DAL na ich wykonanie poprzez wywołanie metody ``.define_tables()`` adaptera. Tabele zdefiniowane wraz z listą informacji o skrzynkach pocztowych serwera IMAP. 


#### Połączenie

Oto zalecany kod rozpoczęcia wsparcia IMAP w modelu aplikacji dla pojedynczego konta pocztowego.

``
# Wstaw użytkownika, hasło, serwer i port w definicji połączenia
# Ustaw port na 993 dla połączeń SSL
imapdb = DAL("imap://user:password@server:port", pool_size=1)
imapdb.define_tables()
``:code

Zauważ, że ``<imapdb>.define_tables()`` zwraca słownik składający się z ciągów zmapowanych nazw tabel DAL z nazwami skrzynek pocztowych serwera o nastepującej strukturze ``{<tablename>: <server mailbox name>, ...}``, abyś otrzymał właściwą nazwę skrzynki pocztowej na serwerze IMAP.

Jesli zechciałbyś ustawić własną konfigurację tabela/skrzynka pocztowa i pominąć automatyczną konfigurację nazw, możesz przekazać własny słownik do adaptera w następujący sposób:

``
imapdb.define_tables({"inbox": "MAILBOX", "trash", "SPAM"})
``:code

Aby ułatwić operowanie różnymi natywnymi nazwami skrzynek pocztowych w interfejsie użytkownika, poniższe atrybuty pozwalają na dostęp do automatycznie przypisanych przez adapter nazw skrzynek pocztowych (która skrzynka pocztowa odpowiada jakiej tabeli i odwrotnie):

-------------------------------------
**Attribute** | **Type** | **Format**
imapdb.mailboxes | dict | ``{<tablename>: <server native name>, ...}``
imapdb.<table>.mailbox | string | ``"server native name"``
-------------------------------------

Pierwszy może być użyteczny w celu pobrania zestawu zapytań IMAP przez natywną skrzynkę pocztową usługi emailowej

``
# mailbox jest ciągiem znaków zawierającym aktualną nazwę skrzynki pocztowej
tablenames = dict([(v,k) for k,v in imapdb.mailboxes.items()])
myset = imapdb(imapdb[tablenames[mailbox]])
``:code

#### Przechwytywanie maila i aktualizacja flag

Oto lista komend IMAP, które możesz zastosować w kontrolerze. Na potrzeby poniższych przykładów, założono, że skrzynka pocztowa twojej usługi IMAP nazywa się ``INBOX``, czyli tak samo jak w Gmail(r).


Aby zliczyć nieprzeczytane wiadomości mniejsze niż 60000 oktetów w twojej skrzynce wiadomości przychodzących wykonaj:
``
q = imapdb.INBOX.seen == False
q &= imapdb.INBOX.created == request.now.date()
q &= imapdb.INBOX.size < 6000
unread = imapdb(q).count()
``:code


Możesz zebrać wiadomości z poprzedniego zapytania stosując:
``
rows = imapdb(q).select()
``:code


Powszechne operatory zapytania są zaimplementowane, włączając belongs

``
messages = imapdb(imapdb.INBOX.uid.belongs(<uid sequence>)).select()
``:code

**Pamiętaj**: Aby uniknąć zapchania serwera zbyt obszernymi komendami select, ważnym jest, aby rozmiar wyników zapytania utrzymywany był poniżej ustalonego progu.

W celu szybszych zapytań, zaleca się stosowanie przefiltrowanych zestawów pól:
``
fields = ["INBOX.uid", "INBOX.sender", "INBOX.subject", "INBOX.created"]
rows = imapdb(q).select(*fields)
``:code

Adapter wie kiedy ma pobrać częściową zawartość wiadomości ( pola takie jak ``content``,``size`` i ``attachments`` wymagają pobrania wszystkich danych zawartych w wiadomości.

Wyniki zapytania select można przefiltrować stosując limitby oraz sekwencje pól poczty.
``
# Wstaw aktualne wartości w miejsce argumentów
myset.select(<fields sequence>, limitby=(<int>, <int>))
``:code

Powiedzmy, że chcesz aby akcja w aplikacji wyswietliła wiadomość. Najpierw pobieramy tą wiadomość (jesli twoja usługa IMAP daje ci taką możliwość, pobierz wiadomości używając pola ``uid``, aby uniknąć odniesień do starych sekwencji).

``
mymessage = imapdb(imapdb.INBOX.uid == <uid>).select().first()
``:code

W przeciwnym razie użyj ``id``.

``
mymessage = imapdb.INBOX[<id>]
``:code

Korzystanie z id jako referencji nie jest zalecane, gdyż numery sekwencji mogą sie zmienić w wyniku procesu konserwacji poczty takich jak usuwanie wiadomości. Jeśli jednak wciąż chcesz przypisać referencje do wiadomości (np. w innym polu bazy danych), rozwiązaniem będzie użycie pola uid jako referencji jeśli dostępne i pobrania każdej wiadomości z zapisaną wartością.

Na koniec, aby wyświetlić zawartość wiadomości, wstaw coś podobnego do widoku

``
{{=P(T("Message from"), " ", mymessage.sender)}}
{{=P(T("Received on"), " ", mymessage.created)}}
{{=H5(mymessage.subject)}}
{{for text in mymessage.content:}}
  {{=DIV(text)}}
  {{=TR()}}
{{pass}}
``:code


Aby stworzyć listę wiadomości w widoku, można posłużyć się helperem ``SQLTABLE``.

``
{{=SQLTABLE(myset.select(), linkto=URL(...))}}
``:code

Oczywiście, możliwym jest również zasilenie helpera formularza odpowiednią wartością id sekwencji

``
{{=SQLFORM(imapdb.INBOX, <message id>, fields=[...])}}
``:code

Aktualnie dostępne wspomagane pola adaptera są nastepujące:

---------------------------------------
**Field** | **Type** | **Description**
uid | string | ````
answered | boolean | Flag
created | date | ````
content | list:string | A list of text or html parts
to | string | ````
cc | string | ````
bcc | string | ````
size | integer | the amount of octets of the message*
deleted | boolean | Flag
draft | boolean | Flag
flagged | boolean | Flag
sender | string | ````
recent | boolean | Flag
seen | boolean  | Flag
subject | string| ````
mime | string | The mime header declaration
email | string | The complete RFC822 message**
attachments | list | Each non text decoded part as dictionary
encoding | string | The message's main detected charset
---------------------------------------------------

*Od strony aplikacji mierzy się go jako długość ciągu RFC822 wiadomości

**UWAGA**: w związku z tym, że id wierszy przypisane są do numerów sekwencji emaila, aby uniknąć niepożądanej aktualizacji lub usunięcia innych wiadomości, należy upewnić się, że twój klient IMAP aplikacji web2py nie usuwa wiadomości w trakcie wykonywania select lub update.


Standardowe operacje ``CRUD`` bazy danych nie są wspomagane. Nie ma możliwości zdefiniowania własnych pól lub tabel i wstawienia innych typów danych, gdyż aktualizacja skrzynek pocztowych za pomocą serwisu IMAP jest zazwyczaj ograniczona do wystawienia flag aktualizacji na serwerze. Wciąż jednak możliwy jest dostęp do komend tych flag poprzez interface DAL IMAP.

Aby oznaczyć wiadomości z ostatniego zapytania jako przeczytane:
``
seen = imapdb(q).update(seen=True)
``:code


A tak usuwamy wiadomości w bazie danych IMAP od pana Gumpy
``
deleted = 0
for tablename in imapdb.tables():
    deleted += imapdb(imapdb[tablename].sender.contains("gumby")).delete()
``:code


Możliwe jest również oznaczenie wiadomości do usunięcia zamiast wymazywać je odrazu za pomocą
``
myset.update(deleted=True)
``:code

``IMAP``:inxx
