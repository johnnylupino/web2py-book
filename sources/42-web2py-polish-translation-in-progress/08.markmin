## Wiadomości Email i SMS

``wiadomości email``:inxx

### Konfiguracja obsługi poczty elektronicznej

Platforma web2py udostępnia klasę ``gluon.tools.Mail`` umożliwiającą łatwe wysyłanie wiadomości email z poziomu web2py. Definicja mailera może wyglądać następująco:
``
from gluon.tools import Mail
mail = Mail()
mail.settings.server = 'smtp.przyklad.com:25'
mail.settings.sender = 'twoj@przyklad.com'
mail.settings.login = 'użytkownik:hasło'
``:code

Uwaga, jeśli aplikacja stosuje uwierzytelnianie ``Auth`` (omówione w następnej części), to obiekt ``auth`` będzie udostępniał własny mailer w metodzie ``auth.settings.mailer``, tak więc można zamiennie zastosować następujące ustawienia:
``
mail = auth.settings.mailer
mail.settings.server = 'smtp.przyklad.com:25'
mail.settings.sender = 'twoj@przyklad.com'
mail.settings.login = 'użytkownik:hasło'
``:code

W mail.settings wstaw odpowiednie parametry swojego serwera SMTP. Ustaw ``mail.settings.login = None`` jeśli serwer SMTP nie wymaga uwierzytelnienia. Jeśli nie zamierzasz używać TLS, ustaw ``mail.settings.tls = False``

``rejestracja zdarzeń poczty elektronicznej``:inxx

--------
W celu śledzenia błędów ustaw:
``
mail.settings.server = 'logging'
``:code
a wiadomości email nie będą wysyłane, lecz zapisywane do konsoli.
-------

#### Konfiguracja emaila w Google App Engine
``poczta elektroniczna w GAE``:inxx
Aby wysłać wiadomość email z konta na Google App Engine:

``
mail.settings.server = 'gae'
``:code

W czasie pisania tego tekstu web2py nie obsługiwał załączników i szyfrowania wiadomości na Google App Engine. Trzeba mieć na uwadze, że cron i terminarz nie działają w GAE.

#### Szyfrowanie x509 i PGP
``PGP``:inxx ``x509``:inxx

W celu wysyłania wiadomości email zaszyfrowanych w standarcie x509 (SMIME) trzeba wykonać następującą konfigurację:
``
mail.settings.cipher_type = 'x509'
mail.settings.sign = True
mail.settings.sign_passphrase = 'twoja tajna fraza'
mail.settings.encrypt = True
mail.settings.x509_sign_keyfile = 'nazwapliku.key'
mail.settings.x509_sign_certfile = 'nazwapliku.cert'
mail.settings.x509_crypt_certfiles = 'nazwapliku.cert'
``:code

Istnieje możliwość wysyłania wiadomości email szyfrowanych w PGP. Przede wszystkim należy zainstalować pakiet python-pyme. Następnie można użyć GnuPG (GPG) w celu utworzenia pliku klucza dla metody sender (pobierającej adres wiadomości z mail.settings.sender) oraz umieścić pliki pubring.gpg i secring.gpg w katalogu (np. "/home/www-data/.gnupg").

Zastosuj nastepujące ustawienia:

``
mail.settings.gpg_home = '/home/www-data/.gnupg/'
mail.settings.cipher_type = 'gpg'
mail.settings.sign = True
mail.settings.sign_passphrase = 'twoje hasło'
mail.settings.encrypt = True
``:code

### Wysyłanie wiadomości email
``mail.send``:inxx ``email html``:inxx ``email attachments``:inxx

Po zdefiniowaniu mailera ``mail`` wiadomość email można wysłać stosując:
``
mail.send(to=['ktoś@przykład.com'],
          subject='cześć',
          # Jeśli reply_to zostanie pominięty, użyty zostanie mail.settings.sender 
          reply_to='my@przykład.com',
          message='Jak się masz')
``:code

Metoda ``mail.send()`` w razie powodzenia zwraca True a w przeciwnym wypadku False. Pełny wykaz argumentów tej metody jest następujący:
``
send(self, to, subject='None', message='None', attachments=[],
     cc=[], bcc=[], reply_to=[], sender=None, encoding='utf-8',
     raw=True, headers={})
``:code

Zwróć uwagę, że ``to``, ``cc``, and ``bcc`` zawierają listę adresów emailowych.

``sender`` ustawiony jest domyślnie na ``None`` i w tym przypadku nadawca będzie ustawiony na  ``mail.settings.sender``.

``headers`` to słownik z nagłówkami, który oczyszcza nagłówki zanim nastapi wysłanie emaila. Na przykład:

``
headers = {'Return-Path' : 'powrót@przykład.org'}
``:code

Poniżej zademonstrowane są dodatkowe przykłady użycia ``mail.send()``.

#### Prosty tekst wiadomości email

``
mail.send('twój@przykład.com',
  'Tytuł wiadomości',
  'Ciało tekstu wiadomości')
``:code

#### Emaile HTML 

``
mail.send('twój@przykład.com',
  'Tytuł wiadomości',
  '<html>Ciało html</html>')
``:code

Jeśli ciało wiadomości email zaczyna się od ``<html>`` i kończy na ``</html>``, zostanie ona wysłana jako HTML.

#### Połączenie emaila tekstowego z emailem HTML

Wiadomość zawarta w emailu może mieć postać tupli (text, html):

``
mail.send('twój@przykład.com',
  'Tytuł wiadomości',
  ('Czysty tekst ciała', '<html>Ciało html</html>'))
``:code

#### Emaile ``cc`` i ``bcc`` 

``
mail.send('twój@przykład.com',
  'Tytuł wiadomości',
  'Czysty tekst ciała',
  cc=['inny1@przykład.com', 'inny2@przykład.com'],
  bcc=['inny3@przykład.com', 'inny4@przykład.com'])
``:code

#### Załączniki

``
mail.send('twój@przykład.com',
  'Tytuł wiadomości',
  '<html><img src="cid:zdjęcie" /></html>',
  zalaczniki = mail.Attachment('/scieżka/do/zdjęcia.jpg', content_id='zdjęcie'))
``:code

#### Wiele załączników

``
mail.send('twój@przykład.com',
  'Tytuł wiadomości',
  'Ciało wiadomości',
  zalaczniki = [mail.Attachment('/ścieżka/do/pierwszego.pliku'),
                 mail.Attachment('/ścieżka/do/drugiego.pliku')])
``:code

### Wysyłanie wiadomości SMS
``SMS``:inxx
Do wysłania wiadomości SMS za pomocą aplikacji web2py konieczna jest usługa zewnętrzna, która prześle wiadomość do odbiorcy. Zazwyczaj jest to usługa odpłatna, ale zależy to od kraju. Sprawdziliśmy kilka z nich, niestety ze słabym skutkiem. Firmy telekomunikacyjne blokują emaile wysyłane za ich pomocą, gdyż są one najczęściej źródłem spamu. 

Lepszą alternatywą jest wykorzystanie firm telekomunikacyjnych do przesyłania SMS-ów. Każda z nich, bowiem, przypisuje unikatowy adres emailowy do numeru telefonu komórkowego, dzięki czemu wiadmości SMS mogą być wysyłane jako emaile na telefon komórkowy. 

Web2py posiada moduł, który ułatwia to zadanie:
``
from gluon.contrib.sms_utils import SMSCODES, sms_email
email = sms_email('1 (111) 111-1111','T-Mobile USA (tmail)')
mail.send(to=email, subject='test', message='test')
``:code

SMSCODES to słownik, który przypisuje nazwy największych firm telekomunikacyjnych do przyrostka adresu emailowego. Funkcja ``sms_email`` zwraca adres emailowy telefonu składający się z numeru telefonu (jako ciągu znaków) oraz nazwy firmy telekomunikacyjnej .

### Wykorzystanie systemu szablonów do generowania wiadomości
``wiadomości email``:inxx

Do wygenerowania wiadomości można wykorzystać system szablonów. Rozważmy przykładową tablicę bazy danych:
``
db.define_table('osoba', Field('imię'))
``:code

gdzie do każdej osoby w bazie danych chcemy wysłać następującą wiadomość, zawartą w pliku  "message.html" umieszczonym w widoku:
``
Drogi {{=osoba.imię}},
Wygrałeś drugą nagrodę, zestaw noży do krojenia steków.
``:code

Można tego dokonać w następujący sposób:
``
for person in db(db.person).select():
    context = dict(person=person)
    message = response.render('wiadomość.html', context)
    mail.send(to=['ktos@przykład.com'],
              subject='None',
              message=message)
``:code

Większą część zadania wykonuje wyrażenie
``
response.render('wiadomość.html', context)
``:code

Przekazuje ono zmienne zdefiniowane w słowniku "contex" do pliku "wiadomość.html", i zwraca ciąg znaków wraz z tekstem wiadomości email. Context to słownik zawierający zmienne, które będą udostepnione plikowi szablonu.

Jeśli wiadomośc email zaczyna się od ``<html>`` i kończy na ``</html>``, email będzie miał charakter HTML.

Zauważ, że w celu załączenia do wiadomości email linku powrotnego do twojej strony internetowej, można użyć funkcji ``URL``. Niestesty, funkcja ``URL`` domyślnie generuje względny adres URL, który nie zadziała poprawnie w przypadku wiadomości email. Aby wygenerować absolutną ścieżkę URL, należy sprecyzować argumenty ``scheme`` i ``host`` w funkcji URL. Na przykład:
``
<a href="{{=URL(..., scheme=True, host=True)}}">Kliknij tutaj</a>
``:code

or

``
<a href="{{=URL(..., scheme='http', host='www.strona.com')}}">Kliknij tutaj</a>
``:code

Ten sam mechanizm szablonów, który służy do wygenerowania tekstu wiadomości email może posłużyć do stworzenia zarówno wiadomości SMS jak i wiadomości innego typu.

### Wysyłanie wiadomości za pomocą zadania uruchomionego w tle


Wysłanie wiadomości email może trwać nawet do kilkunastu sekund, gdyż najczęściej wykjorzystywany jest do tego celu zdalny serwer SMTP wymagający procesu logowania i nawiązania łączności. Aby skrócić użytkownikowi czas oczekiwania na zakończenie tej operacji, pożądane jest czasem ustawienie wiadomości email w kolejce do wykonania w późniejszym czasie, za pomocą zadania w tle. Jak opisano w Rozdziale 4, zadanie takie można ustawić samemu tworząc własna kolejkę lub korzystając z terminarza. Poniżej przedstawiono przykład wykorzystania własnej kolejki zadań.

Najpierw, w pliku modelu naszej aplikacji tworzymy model bazy danych do przechowywania wiadomości email:
``
db.define_table('kolejka',
    Field('status'),
    Field('email'),
    Field('tytuł'),
    Field('wiadomość'))
``:code

Za pomoca kontrolera wiadomości do wysłania wstawiamy do kolejki:
``
db.queue.insert(status='oczekujące',
                email='twój@przykład.com',
                subject='test',
                message='test')
``:code

Nastepnie, wykorzystamy działający w tle skrypt, który odczytuje kolejkę i przesyła wiadomości:
``
## w pliku /app/private/mail_queue.py
import time
while True:
    rows = db(db.queue.status=='oczekujące').select()
    for row in rows:
        if mail.send(to=row.email,
            subject=row.subject,
            message=row.message):
            row.update_record(status='wysłane')
        else:
            row.update_record(status='nieudane')
        db.commit()
    time.sleep(60) # sprawdzaj co minutę
``:code

Na koniec, tak jak opisano w Rozdziale 4, posługując się ponizszymi opcjami, musimy wykonać skrypt mail_queue.py w taki sposób, jak gdbyby był umieszczony wewnątrz kontrolera naszej aplikacji.
``
python web2py.py -S app -M -R applications/app/private/mail_queue.py
``:code

gdzie opcja ``-S app`` nakazuje web2py wykonanie "mail_queue.py" jako "app", ``-M`` nakazuje web2py wykonanie operacji na modelach.

Zakładamy , że obiekt ``mail``, do którego odnosi się "mail_queue.py" zdefiniowany jest w pliku modelowym naszej aplikacji, a dzięki opcji ``-M`` jest on dostępny w skrypcie "mail_queue.py". W celu uniknięcia zablokowania bazy danych przez inny, współbieżny proces, wszelkich zmian należy dokonywać jak najszybciej.

Jak wspomniano w Rozdziale 4, ten typ procesów uruchamianych w tle nie powinien być wykonywany przez  cron (za wyjątkiem, powiedzmy, cron @reboot), gdyż tylko jedno zdarzenie takiego typu może być wykonywane w danej chwili.

Jednym z uniedogodnień korzystania z procesu uruchamianego w tle w celu wysyłania wiadomości email jest  trudność przekazania informacji zwrotnej do użytkownika na wypadek, gdyby wysyłanie emaila zakończyła się niepowodzeniem. Jeśli wiadomość zostanie wysłana bezpośrednio z kontrolera, ewentualne błędy mogą być natychmiast przechwycone i przesłane do użytkownika. W przypadku procesu w tle, email wysyłany jest asynchronicznie, już po zwróceniu odpowiedzi przez kontroler, utrudniając tym samym powiadomienie użytkownika o błędzie.


### Czytanie i zarządzanie skrzynkami pocztowymi (Eksperymentalne)

Adapter ``IMAP`` jest interfejsem emailowych serwerów, a jego zadanie polega na wykonywaniu prostych zapytań w składni ``DAL`` web2py, w taki sposób, aby czytanie, przeszukiwanie oraz inne usługi IMAP poczty elektronicznej takie, jak wdrożone przez Google(r) czy Yahoo(r), mogły być zarządzane z poziomu aplikacji web2py.

Tworzy on własne tabele i nazwy pól w sposób "statyczny", a to oznacza, że twórca oprogramowania nie powinien ich sam definiować, lecz pozwolić procesowi DAL na ich wykonanie poprzez wywołanie metody ``.define_tables()`` adaptera. Tabele są zdefiniowane wraz z listą informacji o skrzynkach pocztowych serwera IMAP. 


#### Nawiązanie połączenia

Oto zalecany kod rozpoczęcia wsparcia IMAP w modelu aplikacji dla pojedynczego konta poczty elektronicznej.

``
# Wstaw użytkownika, hasło, serwer i port w definicji połączenia
# Ustaw port na 993 dla połączeń SSL
imapdb = DAL("imap://user:password@server:port", pool_size=1)
imapdb.define_tables()
``:code

Zauważ, że ``<imapdb>.define_tables()`` zwraca słownik składający się z ciągu zmapowanych nazw tabel DAL z nazwami skrzynek pocztowych serwera o nastepującej strukturze ``{<tablename>: <server mailbox name>, ...}``, w taki sposób aby uzyskać odpowiednią nazwę skrzynki pocztowej na serwerze IMAP.

W celu stworzenia własnej konfiguracji tabela/skrzynka pocztowa i pominięcia automatycznej konfiguracji nazw, można przekazać własny słownik do adaptera w poniższy sposób:

``
imapdb.define_tables({"inbox": "MAILBOX", "trash", "SPAM"})
``:code

Aby ułatwić operowanie różnymi natywnymi nazwami skrzynek pocztowych w interfejsie użytkownika, poniższe atrybuty pozwalają na dostęp do automatycznie przypisanych przez adapter nazw skrzynek pocztowych (która natywna skrzynka pocztowa odpowiada danej tabeli i odwrotnie):

-------------------------------------
**Attribute** | **Type** | **Format**
imapdb.mailboxes | dict | ``{<tablename>: <server native name>, ...}``
imapdb.<table>.mailbox | string | ``"server native name"``
-------------------------------------

Pierwszy atrybut może być wykorzystany w celu pobrania zestawu zapytań IMAP przez natywną skrzynkę pocztową usługi poczty elektronicznej

``
# mailbox jest ciągiem znaków zawierającym aktualną nazwę skrzynki pocztowej
tablenames = dict([(v,k) for k,v in imapdb.mailboxes.items()])
myset = imapdb(imapdb[tablenames[mailbox]])
``:code

#### Przechwytywanie wiadomości email i aktualizacja flag

Oto lista komend IMAP, które można zastosować w kontrolerze. Na potrzeby poniższych przykładów, założono, że skrzynka pocztowa usługi IMAP nazywa się ``INBOX``, czyli tak samo jak w Gmail(r).


Aby zliczyć nieprzeczytane wiadomości mniejsze niż 60000 oktetów w skrzynce wiadomości przychodzących można wykonać:
``
q = imapdb.INBOX.seen == False
q &= imapdb.INBOX.created == request.now.date()
q &= imapdb.INBOX.size < 6000
unread = imapdb(q).count()
``:code


Wiadomości z poprzedniego zapytania mozna zebrać stosując:
``
rows = imapdb(q).select()
``:code


Zaimplementowano najpowszechniejsze operatory zapytań , włączając belongs

``
messages = imapdb(imapdb.INBOX.uid.belongs(<uid sequence>)).select()
``:code

**Warto pamiętać**: W celu unikniecia zapchania serwera zbyt obszernymi komendami select, rozmiar wyników zapytania należy utrzymywać poniżej zadanego progu.

W celu szybszych zapytań, zaleca się stosowanie przefiltrowanych zestawów pól:
``
fields = ["INBOX.uid", "INBOX.sender", "INBOX.subject", "INBOX.created"]
rows = imapdb(q).select(*fields)
``:code

Adapter wie kiedy ma pobrać częściową zawartość wiadomości ( pola takie jak ``content``,``size`` i ``attachments`` wymagają pobrania wszystkich danych zawartych w wiadomości.

Wyniki zapytania select można przefiltrować stosując limitby oraz sekwencje pól skrzynki pocztowej.
``
#W miejsce argumentów wstaw aktualne wartości
myset.select(<fields sequence>, limitby=(<int>, <int>))
``:code

Powiedzmy, że akcja w aplikacji ma wyswietlić wiadomość ze skrzynki pocztowej. Najpierw pobieramy tą wiadomość (jesli usługa IMAP daje taką możliwość, wiadomości można pobrać używając pól ``uid``, by uniknąć odniesień do starszych sekwencji).

``
mymessage = imapdb(imapdb.INBOX.uid == <uid>).select().first()
``:code

W przeciwnym razie można użyć ``id`` wiadomości.

``
mymessage = imapdb.INBOX[<id>]
``:code

Korzystanie z id jako referencji nie jest zalecane, gdyż numery sekwencji mogą sie zmienić w wyniku procesów konserwacji poczty elektronicznej takich jak usuwanie wiadomości. Jeśli jednak wciąż wymagane jest przypisanie referencji do wiadomości (np. w innym polu bazy danych), rozwiązaniem będzie użycie pola uid jako referencji jeśli jest dostępne oraz pobrania każdej wiadomości z przypisaną wartością.

Na koniec, aby wyświetlić zawartość wiadomości w widoku, można zastosować poniższy przykład

``
{{=P(T("Message from"), " ", mymessage.sender)}}
{{=P(T("Received on"), " ", mymessage.created)}}
{{=H5(mymessage.subject)}}
{{for text in mymessage.content:}}
  {{=DIV(text)}}
  {{=TR()}}
{{pass}}
``:code


Aby stworzyć listę wiadomości w widoku, można posłużyć się helperem ``SQLTABLE``.

``
{{=SQLTABLE(myset.select(), linkto=URL(...))}}
``:code

Oczywiście, możliwym jest również zasilenie helpera formularza odpowiednią wartością id sekwencji

``
{{=SQLFORM(imapdb.INBOX, <message id>, fields=[...])}}
``:code

Aktualnie wspomagane pola adaptera są nastepujące:

---------------------------------------
**Pole** | **Typ** | **Opis**
uid | string | ````
answered | boolean | Flaga
created | date | ````
content | list:string | Lista zawierająca tekst lub fragmenty html
to | string | ````
cc | string | ````
bcc | string | ````
size | integer | Ilość oktetów wiadomości email*
deleted | boolean | Flaga
draft | boolean | Flaga
flagged | boolean | Flaga
sender | string | ````
recent | boolean | Flaga
seen | boolean  | Flaga
subject | string| ````
mime | string | Deklaracja nagłówka mime
email | string | Cała zawartość wiadomości w standardzie RFC822**
attachments | list | Każda zakodowana nietekstowa część jako słownik
encoding | string | Kodowanie znaków części głównej wiadomości
---------------------------------------------------

*Od strony aplikacji mierzy się go jako długość ciągu RFC822 wiadomości

**UWAGA**: w związku z tym, że numery id wierszy przypisane są do numerów sekwencji wiadomości, aby uniknąć niepożądanej aktualizacji lub usunięcia wiadomości, należy upewnić się, że klient IMAP aplikacji web2py nie usuwa wiadomości w trakcie wykonywania operacji select lub update.


Standardowe operacje ``CRUD`` bazy danych nie są wspomagane. Nie ma możliwości zdefiniowania własnych pól lub tabel oraz wstawienia innych typów danych, gdyż aktualizacja skrzynek pocztowych za pomocą serwisu IMAP jest zazwyczaj ograniczona do wystawienia flag aktualizacji na serwerze. Wciąż jednak możliwy jest dostęp do komend tych flag poprzez interface DAL IMAP.

Aby oznaczyć wiadomości z ostatniego zapytania jako przeczytane:
``
seen = imapdb(q).update(seen=True)
``:code


A tak usuwamy wiadomości w bazie danych IMAP od pana Gumby
``
deleted = 0
for tablename in imapdb.tables():
    deleted += imapdb(imapdb[tablename].sender.contains("gumby")).delete()
``:code


Możliwe jest również oznaczenie wiadomości do usunięcia zamiast wymazywania ich odrazu za pomocą
``
myset.update(deleted=True)
``:code

``IMAP``:inxx
